package ch07.Quiz;

public class Quiz1_5 {
	
	/*
	 
	 1. 자바의 상속에 대한 설명 중 틀린 것은 무엇입니까?
	 - 자바는 다중 상속을 허용한다  (x) (자바 = 단일상속, C++ = 다중상속) (다중상속 = 둘 이상의 부모 클래스에서 하나의 자식클래스가 둘 다 상속 받음)
	 - 부모의 메소드를 자식 클래스에서 재정의(오버라이딩)할 수 있다
	 - 부모의 private 접근 제한을 갖는 필드와 메소드는 상속의 대상이 아니다
	 - final 클래스는 상속할 수 없고, final 메소드는 오버라이딩할 수 없다
	 
	 
	 2. 클래스 타입 변환에 대한 설명 중 틀린 것은 무엇입니까? (Parent parent = new Child();) //(부모타입 변수 = 자식타입 객체;)
	 - 자식 객체는 부모 타입으로 자동 타입 변환된다 
	 - 부모 객체는 어떤 자식 타입으로도 강제 타입 변환된다 (x) (자식타입이 부모타입으로 자동 타입 변환된 후, 다시 자식타입으로 변환 될 때만 강제 타입 변환 가능) //(자식타입 변수 = (자식타입) 부모타입 객체;)
	 - 자동 타입 변환을 이용해서 필드와 매개변수의 다형성을 구현한다
	 - 강제 타입 변환 전에 instanceof 연산자로 변환 가능한지 검사하는 것이 좋다
	 
	 
	 3. final 키워드에 대한 설명으로 틀린 것은?
	 - final 클래스는 부모 클래스로 사용할 수 있다 (x) final 클래스, final 메소드는 상속, 오버라이딩 불가
	 - final 필드는 초기화된 후에는 변경할 수 없다 (필드에서 초기화 or 클래스 내 생성자 선언 시 초기화 가능)
	 - final 메소드는 재정의(오버라이딩) 할 수 없다
	 - static final 필드는 상수를 말한다 (예, static final double PI = 3.141592;)
	 
	 
	 4. 오버라이딩(Overriding)에 대한 설명으로 틀린 것은?
	 - 부모 메소드의 시그니처(리턴 타입, 메소드명, 매개변수)와 동일해야 한다
	 - 부모 메소드보다 좁은 접근 제한자를 붙일 수 없다 (예, public(부모) -> private(자식))
	 - @Override 어노테이션을 사용하면 재정의가 활실한지 컴파일러가 검증한다
	 - protected 접근 제한을 갖는 메소드는 다른 패키지의 자식 클래스에서 재정의할 수 없다 (x) (public -> protected -> [default] -> private)
	 
	 //public: 공개, protected: 같은 패키지 or 자식 클래스, [default]: 같은 패키지, private: 내 클래스 안에서만 사용
	 
	 
	 5. 추상 클래스에 대한 설명으로 틀린 것은?
	 - 직접 객체를 생성할 수 없고, 상속만 할 수 있다
	 - 추상 메소드를 반드시 가져야 한다 (x)
	 - 추상 메소드는 자식 클래스에서 재정의(오버라이딩)할 수 있다 (자식 클래스에서 메소드 재정의 하려고 쓰는 방법)
	 - 추상 메소드는 재정의하지 않으면 자식 클래스도 추상 클래스가 되어야 한다 (추상 메소드는 블록이 없어서 자식 클래스의 메소드에서 무조건 재정의 되어야 함, 없을 경우 자식 클래스가 또 다른 자식 클래스에게 상속하여 재정의 해야 함)
	 
	 
	 */

}
