컬렉션 자료구조

	1. 컬렉션 프레임 워크
	2. List 컬렉션
	3. Set 컬렉션
	4. Map 컬렉션
	5. 검색 기능을 강화시킨 컬렉션
	6. LIFO, FIFO 컬렉션
	7. 동기화된 컬렉션
	8. 수정할 수 없는 컬렉션
	
-----------------------------------------------------------------------------------------------------------------------------
	
	데이터 자료구조
		- 컴퓨터가 데이터를 효율적으로 다룰 수 있게 도와주는 데이터 보관 방식, 데이터 연산에 관한 총체

	자바 컬렉션
		- 데이터들의 집합, 데이터 자료구조 모음
	
	자바 컬렉션 프레임워크 (JCF)
		- 컬렉션 메소드, 컬렉션 구현에 필요한 인터페이스 제공
		
	
	
	자바 컬렉션 종류
	
		# Map은 컬렉션 상속받진 않지만 컬렉션으로 분류함
		# 자바 컬렉션은 보통 list set map을 말함
		# [인터페이스], 클래스
		# 클래스는 java.util 패기지에 있음
		
		
	[Collection]
	
		- [List] : 순서 O, 중복 O, Null 여러 개 저장 가능
			- ArrayList
			- LinkedList
			- Vector
				- Stack
				
		- [Set] : 순서 X, 중복 X, Null 하나만 저장 가능
			- HashSet
			- LinkedHashSet
			- EnumSet
			
			- [SortedSet]
				- [NavigableSet]
					- TreeSet
			
		- [Queue] : List와 비슷. 순서 O, 중복 O 
			- PriorityQueue
			
			- [Deque]
				- LinkedList
				- ArrayDeque
	
	
	[Map] : 키(key), 값(value) 쌍으로 이뤄진 데이터(=엔트리) 집합, 순서 X, key 중복 X, 값 중복 O
	
		- Hashtable
			- Properties
		
		- HashMap
			- LinkedHashMap
		
			
		- [SortedMap]
			- [NavigableMap]
				- TreeMap
	    
	    
----------------------------------------------------------------------------------------------------

	[Collection]
	
		- [List] : 순서 O, 중복 O 
			- ArrayList
			- LinkedList
			- Vector
				- Stack



	List 컬렉션 
		- 배열과 다르게 생성 후 길이 수정 가능 (추가, 삭제하면 자동으로 길이 조정 됨. 개꿀)
	
	
	List 컬렉션 공통 메소드

		add(인덱스번호, 엘리먼트)			: 인덱스 자리에 추가, 리턴 없음
		add(추가할 엘리먼트)				: 맨 끝에 추가, 추가 결과 boolean 반환
		set(인텍스번호, 교체할 엘리먼트)	: 인덱스번호 엘리먼트를 교체
		 
		contains(객체)				: 리스트 컬렉션에 객체 저장여부 판단. boolean 반환
		get(인덱스번호)					: 인덱스 번호의 객체 리턴
		isEmpty()					: 리스트 컬렉션 비어있는지 여부 판단. boolean 반환
		size()						: 리스트 컬렉션에 저장된 객체 수 리턴
	    
	    clear()						: 리스트 컬렉션의 모든 객체 삭제
	    remove(인덱스번호)				: 인덱스의 객체 삭제
	    remove(객체)					: 객체 탐색 후 삭제. 삭제 성공에 따라 boolean 반환
	    


	    
	□□□□ ArrayList 생성 □□□□
	
		import java.util.List;
		import java.util.ArrayList;
	
		List<Integer> myList = new ArrayList<>();	//Integer 타입의 엘리멘트를 저장하는 ArrayList를 List 인터페이스 타입으로 생성
	
		List myList = new ArrayList();	// 모든 타입 저장
	
		ArrayList<String> myList = new ArrayList<>();	//사용가능하지만 다형성, 유연성이 떨어짐
		


-----------------
	
	Vector
		- ArrayList와 비슷
		- Collection 프레임워크에 없는 메소드도 사용가능
		- Vector 접근은 항상 동기화 되어 있으므로 하나의 스레드만 접근해서 사용 가능
		- 거의 스레드 환경에서만 사용
		
	□□□□ Vector 생성 □□□□
	
		import java.util.List;
		import java.util.Vector;
	
		List<E> myList = new Vector<>(); // E타입의 엘리멘트를 저장하는 Vector를 List 인터페이스 타입으로 생성
		
		List myList = new Vector(); //모든 타입 저장
		
		Vector<E> myList = new Vector<>(); //사용가능하지만 다형성, 유연성이 떨어짐
		
	
-----------------------	    
	    
	LinkedList
		- ArrayList와 사용 방법 동일
		- 단. ArrayList는 연속된 배열에 객체를 저장하고 만약 하나의 객체가 삭제되면 그 뒤의 객체들이 전부 앞으로 하나씩 당겨짐
		- LinkedList는 연속되지않은 배열들을 링크를 통해 순서를 정하고 인접한 객체를 체인처럼 연결해서 관리하므로 하나의 객체가 삭제되어도 인접한 양 옆 두 개의 링크만 바꿔주면 됨 (효율 굿)
		
	
	□□□□ LinkedList 생성 □□□□ 
		
		import java.util.List;
		import java.util.LinkedList;
		
		
		List<E> myList = new LinkedList<>(); //E 타입 저장 가능
		
		List myList = new LinkedList(); //모든 타입 저장 가능



	 ArrayList와 LinkedList에 각각 0번 인덱스에 0~9999를 삽입하는 작업에서
	 
	 i = 0 ~ 9999
	 add(0, i) 를 할 때
	 
	 	ArrayList는 0번에 넣고 이후에 0번에 넣으면 원래 있던 0번과 그 뒷번호 데이터는 새로 0에 넣을 때 마다 뒤로 하나씩 밀림
	 
	 	LinkedList는 사실 인덱스라는 개념이 없고 데이터를 넣은 후 기존 맨 앞에 데이터 앞으로 링크해주면 그게 0번 데이터가 됨 (개꿀)



	# 문자열로 바꾸기
		String.valueOf(바꿀데이터);

----------------------------------------------------------------------------------------------------

	[Collection]
	
		- [Set] : 순서 X, 중복 X, Null 하나만 저장 가능
			- HashSet
			- LinkedHashSet
			- EnumSet
			
			- [SortedSet]
				- [NavigableSet]
					- TreeSet



	Set 컬렉션
		- 저장한 순서를 따르지 않음(인덱스 개념 자체가 없음), 중복데이터는 저장 안 됨, Null 하나만 저장 가능(Null도 중복 안 됨)


	Set 컬렉션 공통 메소드
	
		add(엘리먼트)			: 엘리먼트 추가. 추가 후 성공여부에 따라 boolean 리턴
		
		contains(객체)		: 객체 저장 여부. boolean 리턴
		isEmpty()			: 컬렉션 비어있는지 조사. boolean 리턴
		size()				: 저장되어있는 전체 데이터 수. int 리턴
		
		iterator()			: 저장 객체를 하나씩 가져오는 반복자 리턴. Iterator<E> 인터페이스 타입 리턴
		
		clear()				: 데이터 모두 삭제. 리턴x
		remove(객체)			: set에서 겍체 찾아서 삭제. 삭제여부 boolean 리턴
	
		
		
		# Iterator 반복자를 통해 set에서 데이터를 가져오는데 물리적으로 가져오는 건 아니고 참조해서 가져옴
	
		# Iterator<E> 반복자 인터페이스 메소드
			- hasNext()		: set에서 참조해서 가져올 다음 엘리먼트 존재 여부. boolean 리턴 (set에 실제로 데이터가 존재하고있지만 이미 전부 참조해서 한 번씩 가져갔다면 false임)
			- next()		: set에서 다음 엘리먼트 참조해서 가져오기. E 타입 리턴. hasNext()가 false인 상태에서 이 메소드 호출하면 Exception 발생함
			- remove()		: 현재 참조해서 갖고온 엘리먼트를 set 컬렉션에서 제거. 리턴x


	    
	   

	HashSet
		- 가장 많이 사용하는 Set 컬렉션
		- 동등객체 중복저장 안 함 (동등객체란, hashCode() 리턴값이 같을 때 equals() 리턴값도 같은 객체)
		
	
	□□□□ HashSet 생성 □□□□
		
		import java.util.Set;
		import java.util.HashSet;
		
		
		Set<E> mySet = new HashSet<>(); // E 타입 엘리먼트 저장하는 HashSet 생성
		
		Set mySet = new HashSet(); // 아무타입
		
	
	
	□□□□ HashSet에서 데이터(객체) 하나씩 갖고오기 두 가지 방법 □□□□
	
		1. for문으로 갖고오기
		
			Set<E> mySet = new HashSet<>();
			for(E e : mySet){
				...
			}
			
		
		
		2. Iterator<E>에 iterator() 메소드 사용하여 while문 조건으로 hashNext() 사용하여  next(), remove() 메소드를 통해 객체 하나씩 Iterator 조작하기
			
			Set<E> mySet = new HashSet<>();
			Iterator<E> myIterator = mySet.iterator();
	
			while(myIterator.hasNext()){
				E e = myIterator.next();
				...
			}
		
		
		# 만약 HashSet 객체를 검사해서 같은 객체를 Set에서 remove 하거나 add 하고 싶을 때에는 for문으로 안 되고 무조건 Iterator 사용해야 함.
		# for문의 반복 횟수가 for문을 돌면서 add, remove 하게 되면 변하기 때문에 예외 발생함.

---------------------------------------------------------------------------------------------------------------

	[Map] : 키(key), 값(value) 쌍으로 이뤄진 데이터(=엔트리) 집합, 순서 X, key 중복 X, 값 중복 O
	
		- Hashtable
			- Properties
		
		- HashMap
			- LinkedHashMap
		
			
		- [SortedMap]
			- [NavigableMap]
				- TreeMap

	Map 컬렉션
		- 순서 X ,Key중복 X, 값 중복 O
		- Map.Entry 인터페이스를 구현한 엔트리(키+값) 객체를 저장.
		- 키, 값은 사실 둘 다 객체 주소임
	
		- 키를 매개로 주면 그 키에 맞는 객체 값을 리턴함
		- 같은 키를 가진 엔트리를 저장하면 키 중복이 되지 않아서 새로 저장된 엔트리의 값만 변경



	Map 컬렉션의 주요 공통 메소드
	
		put(키, 값)				: 키와 값으로 Map에 엔트리 추가. (저장된 엔트리의 값만 리턴)
		
		
		containsKey(키)			: Map에 키를 가진 엔트리 존재 여부. (boolean 리턴)
		containsValue(값)		: Map에 값을 가진 엔트리 존재 여부. (boolean 리턴)
		isEmpty()				: Map 컬렉션 비어있는지 여부. (boolean 리턴) 
		
		get(키)					: 주어진 키의 엔트리를 찾아서 값만 리턴. (값 리턴)
		size()					: Map에 저장된 엔트리 객체 개수 리턴(키 갯수와 일치). (int 리턴)
		
		
		keySet()				: Map에 저장된 모든 엔트리 객체의 키만 Set에 담아서 Set리턴. (Set<키> 리턴)
		entrySet()				: Map에 저장된 모든 엔트리 객체(키+값)를 Set에 담아서 Set리턴. (Set<Map.Entry<키,값>> 리턴)
		
		values()				: Map에 저장된 모든 엔트리 객체의 값만 Collection에 담아서 리턴. (Collection<값> 리턴)
		
		
		clear()					: Map에 있는 모든 엔트리객체 삭제. (리턴 X)
		remove(키)				: Map에 있는 특정 키값 갖는 엔트리 삭제. (삭제된 엔트리의 값 리턴)


		# Entry 객체 메소드
			entry.getKey()		: 엔트리의 키 갖고오기. 리턴 키
			entry.getValue()	: 엔트리의 값 갖고오기. 리턴 값

------------------------------------------------------------------------------------------

	HashMap
		- 키 = 동등객체 (hashCode() 리턴값이 같을 때 equals() 리턴값 같음)
		- 동등객체 중복 방지
		- Set 인터페이스 구현 객체에 키 또는 엔트리(키+값)를 담을 수 있음. 이후에 Iterator 사용하여 엔트리 객체 뽑아 쓰기 가능
		- Collection 구현 객체에 값만 담을 수 있음.


	□□□□ HashMap 만들기, Set 구현객체에 엔트리 객체 넣고 Iterator 반복자로 뽑아쓰기 □□□□
	
		import java.util.Map;
		import java.util.Map.Entry;
		import java.util.HashMap;
		
		import java.util.Set;
		import java.util.Iterator;
	
	
		Map<String, Integer> myMap = new HashMap<>();
		
		myMap.put("김개똥", 32); //리턴값 32
		myMap.put("김개똥", 33); //리턴값 33
		myMap.size(); //리턴값 1
		
		myMap.put("김아무개", 27); //리턴값 27
		myMap.size(); //리턴값 2
		
		myMap.containsKey("김아무개"); //리턴값 true
		myMap.containsValue(32); //리턴값 false
		
		myMap.isEmpty() //리턴값 false
		
		Set<Entry<String, Integer>> mySet1 = myMap.entrySet();
		Set<String> mySet2 = myMap.keySet();
		
		Iterator<String, Integer> myIterator = mySet1.iterator();
		while(myIterator.hasNext()){
			myIterator.next();
			...
		}
		
		Collection<Integer> myCol = myMap.values();
	
	
-------------------	
	
	Hashtable
		- HashMap과 같은데, 동기화 되어있어 하나의 스레드만 Hashtable 접근가능 (ArrayList와 Vector와 관계 비슷)
		- 



















	    