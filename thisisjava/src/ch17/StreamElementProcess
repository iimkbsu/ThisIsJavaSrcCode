
스트림 요소 처리
	- 스트림?
	- 내부 반복자
	- 중간 처리와 최종 처리
	- 리소스로부터 스트림 얻기
	- 요소 걸러내기(필터링)
	- 요소 변환(매핑)
	- 요소 정렬
	- 요소 하나씩 처리(루핑)
	- 요소 조건 만족 여부(매칭)
	- 요소 기본 집계
	- 요소 커스텀 집계
	- 요소 수집
	- 요소 병렬 처리
	
	

----------------------------------------------------------------------------

스트림(Stream)
	
	- 요소(엘리먼트)의 흐름
	- java 8 부터 사용가능한 배열의 요소를 반복처리하기 위한 기능
	- 람다식 사용하여 요소(엘리먼트)처리
	


기존의 방식 (외부 반복자 = 컬렉션에서 하나씩 갖고와서 개발자 코드에서 처리)
	- List의 경우 for문을 이용하여 idx 번호에 따라 get(idx)로 갖고오기
	- Set의 경우 향상된 for문으로 하나씩 갖고오거나, 또는 Iterator를 만들어 iterator()으로 for문에 hasNext()로 반복을 걸고 next()로 하나씩 갖고오는 방식
	
		# 외부 반복자(for문 idx, 향상된 for문, Iterator)는 하나씩 갖고와서 코드에서 처리하기 때문에 시간과 자원 낭비가 심함
	

----------------------------------------------------------------------------------


스트림의 내부 반복자
	
	- 개발자 코드에서 람다식으로 처리요청하고 컬렉션에서 내부 반복으로 처리함
	- 시간 자원 낭비 감소
	- 외부 반복자 사용 시 스레드 처리와 같은 번거로움이 없음 (내부 반복자는 알아서 나누고 병렬처리 함)
	- 중간, 말단 처리를 수행하도록 파이프 라인 형성 가능 (외부 반복자는 무조건 하나씩 다 꺼내야 하지만 내부 반복자는 중간, 말단에 조건을 걸러서 필터링, 매핑, 루핑, 매칭 등 가능)
	
	

스트림 방식으로 하나씩 반복처리    forEach( x -> {x처리 리턴} )
	
	Stream<String> myStream = 컬렉션명.stream(); //스트림 재사용 불가, 한 번 사용 시 다시 만들어야 함
	
	myStream.forEach( 요소변수명 -> 요소변수처리내용); //요소변수명 아무거나 가능
	
	
		# 인터페이스 Stream<T> 의 forEach()
	
			# void forEach(Consumer<? super T> action)   //와일드 카드 제네릭, T타입이거나 T의 부모타입이 매개변수타입으로 가능
	
				# Consumer<T> 함수형 인터페이스의 추상메소드 action() //action() 메소드 재정의하거나 람다식으로 처리코드 작성 가능

	
	
	
	
	■■■■ 스트림으로 Set 요소 처리하기 ■■■■
	
		Set<String> mySet = new HashSet<>();
		
		mySet.add("1");
		mySet.add("2");
		mySet.add("3");
		mySet.add("4");
		
		Stream<String> myStream = mySet.stream();
		
		//기본 람다식
		myStream.forEach( (num)->{System.out.println(num)});
		
		//더 줄이는 방법
		myStream.forEach( num -> System.out.println(num));
 
 
 
병렬처리 스트림

	- 컬렉션명.parallelStream()
 
 	Stream<타입> myStream = 컬렉션명.parallelStream();
 	myStream.forEach((변수명)->{처리내용});
 
 
 
 	■■■■ 병렬처리 스트림으로 Set 요소 처리하기 ■■■■
 		
 		Set<String> mySet = new HashSet<>();
		
		mySet.add("1");
		mySet.add("2");
		mySet.add("3");
		mySet.add("4");
		
		Stream<String> myStream = mySet.parallelStream();
		
		//기본 람다식
		myStream.forEach( (num)->{System.out.println(num)});
		
		//더 줄이는 방법
		myStream.forEach( num -> System.out.println(num));

------------------------------------------------------------------------------------


	리소스에서 스트림 얻기
	
		- 보통 컬렉션에서 스트림을 얻지만 리소스(데이터를 갖고있는 객체들)로부터 스트림을 얻을 수도 있음
		
		
		java.util.stream 패키지 안의 스트림 인터페이스
		
			BaseStream (공통 메소드 정의 스트림 인터페이스)
				┠ Stream		: 객체요소 처리 스트림 인터페이스
				┠ IntStream		: int 처리 스트림 인터페이스
				┠ LongStream	: long 처리 스트림 인터페이스
				┗ DoubleStream	: double 처리 스트림 인터페이스
				
		
		
	□□□ 컬렉션으로부터 스트림생성 메소드 □□□
	
		List, Set 컬렉션 → Stream<타입>		: 컬렉션명.stream();	컬렉션명.parallelStream();
		
		
	□□□ 배열, 리소스로부터 스트림생성 메소드 □□□
		
		배열 → Stream<타입>				: Arrays.stream(배열);			Stream.of(배열);
		int배열 → IntStream				: Arrays.stream(int배열);			IntStream.of(int배열);
		long배열 → LongStream				: Arrays.stream(long배열);		LongStream.of(long배열);
		double배열 → DoubleStream			: Arrays.stream(double배열);		DoubleStream.of(double배열);
		
		int 정수 범위 → IntStream			: IntStream.range(정수, 정수);	//끝 미포함	IntStream.rangeClosed(정수, 끝정수); //끝 포함
		long 정수 범위 → LongStream		: LongStream.range(정수, 정수);//끝 미포함	LongStream.rangeClosed(정수, 끝정수); //끝 포함
		
		디렉토리 → Stream<Path>			: Files.list(Path);
		텍스트파일 → Stream<String>			: Files.lines(Path, Charset); //Charset = 유니코드. 예. UTF-8
		
		랜덤수 → DoubleStream				: Random.doubles(...);
		랜덤수 → IntStream				: Random.ints();
		랜덤수 → LongStream				: Random.longs();
		



		# toString() 재정의
		
			@Override
			public String toString() {
				return new StringBuilder()
					.append("{")
					.append("pno : " + pno + ", ")
					.append("name : " + name + ", ")
					.append("price : " + price + ", ")
					.append("}")
					.toString();
			}	
		
		# toString() 메소드는 객체를 사용할 때 자동으로 호출 되어 print(객체)라고 하면 콘솔에 문자열을 출력 해 줌
		# 재정의 하여 원하는 내용을 출력할 수 있게 바꿔주면 사용하는데 좋음
	
	
	
		# 문자열 합치기 (+, concat(), append())
	
			String s1 = "hello";
			String s2 = "world";
			System.out.println(s1 + s2);
	
	
			String s1 = "hello";
			String s2 = "world";
			System.out.println(s1.concat(s2));
	
	
			StringBuffer sb = new StringBuffer();
			sb.append("hello");
			sb.append("world");
			System.out.println(sb.toString()); // toString() 안 써도 자동호출됨
	
	
	
	
	
	■■■■ txt 파일을 한 줄씩 스트림으로 받아오기 ■■■■
	
	import java.nio.charset.Charset;
	import java.nio.file.Files;
	import java.nio.file.Path;
	import java.nio.file.Paths;

	import java.util.stream.Stream;
	
	
	static void main(String[] args) throws Exception {
	
		Path path = Paths.get(StreamExample.class.getResource("data.txt").toURI());
		
		Stream<String> stream = Files.lines(path, Charset.defaultCharset());
		
		stream.forEach(line -> System.out.println(line));
		stream.close();
		
	}



		# URI (Uniform Resource Identifier)
			- 통합자원식별자
			- 웹브라우저 파일, 로컬 파일 등 리소스를 식별할 수 있게 하는 통일된 방식 지원
			- elancer.co.kr
		
		
		# URL (Uniform Resource Locator)
			- URI의 위치 표기 규약
			- 프로토콜(https, http, smp 등)과 URI를 함께 표기
			- https://elancer.co.kr
		
		
		
		# GC(Garbage Collector)가 있는 자바에서 스트림 close() 해주는 이유
	
			자바 코드를 보다보면 close() 메소드가 작성되어 있는걸 볼 수 있다
			그리고 자바를 공부하다 보면 자바는 더 이상 사용하지 않는 메모리를 해제하는 Garbage Collector를 알게 된다
			여기서 생기는 궁금증은 GC가 알아서 메모리를 해제해주는데 close()를 작성해주는 이유는 무엇일까?
			(아래 내용은 개발바닥 유튜브 오픈카톡방에 질문을 올려 알게된 내용을 정리 해둔 것입니다)

			보통 close() 메서드가 있는 클래스들은 OS로부터 자원을 할당 받아 사용하는 네이티브 메소드들을 가지고 있는 경우들이 있는데
			이렇게 C에서 자원을 할당 받은 경우 GC가 자원을 할당 받았는지 알 수가 없기 때문에
			close() 메서드를 통해서 '자원을 그만쓴다'라는 것을 알리고 GC가 메모리를 해제 할 수 있도록 하는 것이다
			이외에 개발자가 직접 정의한 경우는 API 문서를 봐야 어떤 역햘을 하는지 알 수 있다
			또한, 명시적으로 수거가 되도록 표시하는 경우가 있다
 
		개발자가 직접 정의한 경우를 제외한 close() 메소드는 Object의 사용 중지를 알리는 역할이고
		이것의 메모리를 해제해주는 역할은 GC가 하는 것이다
	
	
	
	
--------------------------------------------------------------------------------------------


스트림의 중간처리, 최종처리
	
	- 외부 반복자는 컬렉션에서 무조건 하나씩 요소를 다 꺼내야 함.
	- 스트림은 내부 반복자를 통해 중간, 최종에 조건을 걸어서 필터링, 매핑, 루핑, 매칭, 집계처리 등 가능 (원하는 요소만 뽑아서 수정 가능)

		# 중간처리 : 매핑(map), 필터링(filter, distinct), 정렬(sorted), 반복(peek) 등
		# 최종처리 : 반복(forEach), 카운팅(count), 평균(average), 리듀스(reduce) 등


----------------------------------


 필터링 (요소 거르기, 중간처리)
 	
 	- 스트림이 흘러갈 때 필터링하여 요소 걸러내기
 	
 	
	□□□ 필터링 메소드 □□□
	
		스트림.distinct()				: 스트림에서 중복제거
		컬랙션.stream().distinct() 	: 스트림에서 중복제거
		
			# Stream<객체>일 경우 equals() true인 경우 객체 중복으로 판단
			# 나머지는 값이 같은 경우 중복으로 판단
		
		filter(x -> true/false리턴하는 메소드)		: 리턴이 true면 스트림으로 넘어감, false면 스트림에서 필터링
		
			# filter(Predicate<T>)
			# filter(IntPredicate)
			# filter(LongPredicate)
			# filter(DoublePredicate)
			
			# 함수형 인터페이스 Predicate의 추상 메소드 test()
				true/false 리턴하여 필터링 함
			


	■■■■ 중복 제거, '신'으로 시작하는 이름만 필터링 하기 ■■■■
	
		List<String> list = new ArrayList<>();
		
		list.add("홍길동"); list.add("신용권");
		list.add("김자바"); list.add("신용권"); 
		list.add("신민철");
		
		//중복제거하고 하나씩 출력
		list.stream().distinct().forEach(n -> System.out.println(n));
		
		
		//'신' 씨만 필터링하여 하나씩 출력
		list.stream().filter(n -> n.startsWith("신").forEach(n -> System.out.println(n));
		
		
		//중복제거하고 '신'씨만 필터링하여 하나씩 출력
		list.stream().distinct().filter(n -> n.startsWith("신")).forEach(n -> System.out.println(n));
		

-------------------------

 매핑 (요소 변환, 중간처리)
 
 	- 스트림이 흘러갈 때 요소를 변환한다
 	- 한 개의 요소를 복수 개의 요소로 변환도 가능






	
	