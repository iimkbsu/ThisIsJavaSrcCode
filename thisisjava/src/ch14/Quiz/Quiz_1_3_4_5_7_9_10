
1번, 3번, 4번, 5번, 7번, 9번, 10번


1. 스레드에 대한 설명 중 틀린 것은?
	- 자바 앱은 메인(main)스레드가 main() 메소드를 실행시킨다.
	- 작업 스레드 클래스는 Thread 클래스를 상속해서 만들 수 있다.
	- Runnable 객체는 스레드가 실행해야 할 코드를 가지고 있는 객체라고 볼 수 있다. (Runnable 인터페이스의 구현 클래스의 객체)
	- 스레드 실행을 시작하려면 run() 메소드를 호출해야 한다. (X)
	
	# 스레드.start() 메소드 호출로 스레드를 실행시키면 스레드에 있는 run()메소드가 실행 됨
	


3. 동기화 메소드와 동기화 블록에 대한 설명 중 틀린 것은?
	- 동기화 메소드와 동기화 블록은 싱글(단일) 스레드 환경에서는 필요 없다
	- 스레드가 동기화 메소드를 실행할 때 다른 스레드는 일반 메소드를 호출할 수 없다 (X)
	- 스레드가 동기화 메소드를 실행할 때 다른 스레드는 동기화 메소드를 호출할 수 없다
	- 스레드가 동기화 블록을 실행할 때 다른 스레든느 동기화 메소드를 호출할 수 없다
	
	# synchronized 메소드나 synchronized(공유객체) 블록은 하나의 스레드만 점유해서 실행시킬 수 있음
	# 일반 메소드나 동기화 블록 밖의 메소드 코드는 여러 스레드가 실행할 수 있음



4. 스레드 일시 정지 상태에 대한 설명 중 틀린 것은?
	- sleep(밀리 초) 메소드는 주어진 시간 동안 스레드가 일시 정지 상태가 된다.
	- 스레드가 동기화 메소드르 실행할 때 다른 스레드가 동기화 메소드를 호출하게 되면 일시 정지 상태가 된다.
	- 동기화 메소드 내에서 wait() 메소드를 호출하면 현재 스레드가 일시 정지 상태가 된다.
	- yield() 메소드를 호출하면 현재 스레드가 일시 정지 상태가 된다. (X)
	
	# yield() 메소드를 호출한 스레드는 실행대기 상태가 되고 다른 스레드가 실행 됨

	
	
5. interrupt() 메소드를 호출한 효과에 대한 설명 중 틀린 것은 무엇인가?
	- 일시 정지 상태에서 InterruptedException을 발생시킨다
	- 스레드를 즉시 종료한다 (X)
	- 스레드가 일시 정지 상태가 될 때까지 InterruptedException이 발생하지 않는다.
	- InterruptedException이 발생하지 않았다면 isInterrupted() 메소드는 true를 리턴한다
	
	# interrupt() 메소드는 일시정지 상태의 스레드에게 예외를 발생 시키도록 하는 역할이므로 즉시 종료랑 연관 없다.
	
	
	
7. wait()과 notify() 메소드에 대한 설명 중 틀린 것은?
	- 스레드가 wait()을 호출하면 일시 정지 상태가 된다
	- notify()를 호출하면 wait()로 일시정지 상태에 있던 스레드가 실행 대기 상태가 된다
	- wait()과 notify()는 동기화 메소드 또는 블록에서 호출할 필요가 없다 (X)
	- wait()과 notify()는 두 스레드가 균등하게 번갈아 가면서 실행할 때 사용할 수 있다
	
	# Object 클래스의 wait(), notify(), notifyAll() 메소드는 어떤 클래스든 사용할 수 있음
	# wait() 메소드는 실행중인 스레드가 일시정지 상태가 되게 하고 notify() 메소드는 일시정지 상태 스레드가 실행 대기 상태가 되게 함
	
	
	
9. while 문으로 반복적인 작업을 하는 스레드르 종료시키는 방법에 대한 설명 중 최선의 방법이 아닌 것은?
	- 조건식에 boolean 타입의 stop 플래그를 이용해서 while문을 빠져나가게 한다
	- 스레드가 반복적으로 일시 정지 상태가 된다면 InterruptedException을 발생시켜 예외 처리 코드에서 break 문으로 while 문을 빠져나가게 한다
	- 스레드가 일시 정지 상태로 가지 않는다면 isInterrupted()나 interrupted() 메소드의 리턴값을 조사해서 true일 경우 break 문으로 while 문을 빠져나가게 한다
	- stop() 메소드를 호출한다 (X)
	
	# stop() 메소드는 deprecated(사라지게 될 기능) 됨. 리소스 처리가 완료되지 않은 상태로 종료되어 문제 발생할 수 있기 때문.
	


10. 스레드풀에 대한 설명 중 틀린 것은?
	- 갑작스러운 작업의 증가로 스레드의 폭증을 막기 위해 사용된다
	- ExecutorService 인터페이스 구현객체가 스레드풀이며 newFixedThreadPool(최대 스레드 수) 메소드로 얻을 수 있다
	- 작업은 Runnable 또는  Callable 인터페이스를 구현해서 정의한다
	- execute() 메소드로 작업 처리 요청을 하면 작업이 완료될 때까지 대기(블로킹) 된다 (X)
	
	# execute() 메소드로 작업 처리 요청을 하면 작업 큐에 Runnable 또는 Callable 객체를 저장하고 리턴값은 없음. 
	# 요청 이후, 작업 처리과정이나 결과에는 관심 없는 메소드이므로 블로킹 되지 않음.
	
	
	
	